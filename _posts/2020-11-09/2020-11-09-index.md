---
title:
    Целые числа (int)<br />
    Битовые операции<br />
    Дополнительные методы<br />
    Системы счисления<br />
    Вещественные числа (float)<br />
    Дополнительные методы<br />
    Модули Decimal и Fraction<br />
    Модуль Decimal<br />
    Точность<br />
    Округление<br />
    Стратегия округления<br />
    Модуль Fraction<br />
    Модуль math<br />
    Модуль random<br />
    Комплексные числа (complex)<br />
    Тип bool<br />
    Строки<br />
    Операции над строками<br />
    Тип картедж<br />
    Тип list - список
hasJupyter: 1
show: 1
---


## Целые числа (int)

Они поддерживают набор самых обычных математических операций:

|                |                                           |
|:---------------|:------------------------------------------|
|`x + y`         |Сложение                                   |
|`x - y`         |Вычитание                                  |
|`x * y`         |Умножение                                  |
|`x / y`         |Деление                                    |
|`x // y`        |Получение целой части от деления           |
|`x % y`         |Остаток от деления                         |
|`- x`           |Смена знака числа                          |
|`abs(x)`        |Модуль числа                               |
|`divmod(x, y)`  |Пара `(x // y, x % у)`                     |
|`x ** y`        |Возведение в степень                       |
|`pow(x, y[, z])`|х<sup>у</sup> по модулю (если модуль задан)|

```python
pow(x, y[, z])
```

`x`: Число, которое требуется возвести в степень.

`у`: Число, являющееся степенью, в которую нужно возвести первый аргумент. Если число отрицательное, аргумент `z` не принимается.

`z`: Число, на которое требуется произвести деление по модулю. Если число указано, ожидается, что `х` и `у` положительны и имеют тип `int`.


```python
pow(2, 3)
```




    8




```python
pow(10, 2)
```




    100




```python
pow(10, -2)
```




    0.01




```python
pow(2, 3, 10)
```




    8



Python, в отличие от многих других языков, поддерживает длинную арифметику

## Битовые операции

Над целыми числами также можно производить битовые операции

|        |                         |
|:-------|:------------------------|
|`x \| y` |Побитовое или            |
|`x ^ y` |Побитовое исключающее или|
|`x & y` |Побитовое и              |
|`x << n`|Битовый сдвиг влево      |
|`x >> y`|Битовый сдвиг вправо     |
|`~ x`   |Инверсия битов           |

## Дополнительные методы

`int.bit_length()` - количество бит, необходимых для представления числа в двоичном виде, без учёта знака и лидирующих нулей.


```python
n = -37
bin(n)
```




    '-0b100101'




```python
n.bit_length()
```




    6



## Системы счисления

```
int( [object], [основание системы счисления] )
```

- преобразование к целому числу в десятичной системе счисления. По умолчанию система счисления десятичная, но можно задать любое основание от 2 до 36 включительно.

|        |                                                      |
|:-------|:-----------------------------------------------------|
|`bin(x)`|преобразование целого числа в двоичную строку         |
|`hex(x)`|преобразование целого числа в шестнадцатеричную строку|
|`oct(x)`|преобразование целого числа в восьмеричную строку     |

Примеры:
>>> = int('19') # Переводим строку в
число
>>> = int('19.5') 



```python
a = int('19') # Переводим строку в число
```


```python
b = int('19.5') # Строка не является целым числом
```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    <ipython-input-15-005a877b89e0> in <module>
    ----> 1 b = int('19.5') # Строка не является целым числом
    

    ValueError: invalid literal for int() with base 10: '19.5'


```
Traceback (most recent call last):
 File "", line 1, in
ValueError: invalid literal for int()
 with base 10: '19.5'
```


```python
c = int(19.5) # Применённая к числу с плавающей точкой, отсекает дробную часть
```


```python
print(a, c)
```

    19 19



```python
bin(19)
```




    '0b10011'




```python
oct(19)
```




    '0o23'




```python
hex(19)
```




    '0x13'




```python
0b10011 # Так тоже можно записывать числовые константы
```




    19




```python
int('10011', 2)
```




    19




```python
int('0b10011', 2)
```




    19



## Вещественные числа (float)

Вещественные числа поддерживают те же операции, что и целые. Однако (из-за представления чисел в компьютере) вещественные числа неточны, и это может привести к ошибкам:


```python
0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1
```




    0.9999999999999999



Для высокой точности используют другие объекты (например Decimal и Fraction)).

Также вещественные числа не поддерживают длинную арифметику:


```python
a = 3 ** 1000
print(a)
```

    1322070819480806636890455259752144365965422032752148167664920368226828597346704899540778313850608061963909777696872582355950954582100618911865342725257953674027620225198320803878014774228964841274390400117588618041128947815623094438061566173054086674490506178125480344405547054397038895817465368254916136220830268563778582290228416398307887896918556404084898937609373242171846359938695516765018940588109060426089671438864102814350385648747165832010614366132173102768902855220001



```python
a + 0.1
```


    ---------------------------------------------------------------------------

    OverflowError                             Traceback (most recent call last)

    <ipython-input-31-205f1f1d9d85> in <module>
    ----> 1 a + 0.1
    

    OverflowError: int too large to convert to float


```
Traceback (most recent call last):
  File "", line 1, in
OverflowError: int too large to convert to float
```

Простенькие примеры работы с числами:


```python
c = 150
d = 12.9
c + d
```




    162.9




```python
p = abs(d - c) # модуль числа
print(p)
```

    137.1



```python
round(p) # округление
```




    137



### Дополнительные методы

|                              |                                                           |
|:-----------------------------|:----------------------------------------------------------|
|`float.as_integer_ratio()`    |пара целых чисел, чьё отношение равно этому числу          |
|`float.is_integer()`          |является ли значение целым числом                          |
|`float.hex()`                 |переводит float в hex (шестнадцатиричную систему счисления)|
|`classmethod float.fromhex(s)`|float из шеснадцатиричной строки                           |


```python
(10.5).hex()
```




    '0x1.5000000000000p+3'




```python
float.fromhex('0x1.5000000000000p+3')
```




    10.5



## Модули Decimal и Fraction

Из-за ограничений в сохранении точного значения чисел, даже простейшие математические операции могут выдавать ошибочный результат. Эти ограничения легко преодолимы - достаточно использовать десятичный модуль `Decimal` в `Python`. В выполнении расчетов на основе дробей поможет модуль фракций - `Fraction`.

## Модуль Decimal

Синтаксис:

С помощью `Decimal` вы можете создавать десятичные числа. `Decimal` обеспечивает поддержку правильного округления десятичной арифметики с плавающей точкой.


```python
from decimal import Decimal
number1 = Decimal('0.1')
number2 = Decimal('0.7')
print(number1 + number2)
```

    0.8


## Точность

Контекстом в `Decimal` можно управлять, устанавливая свои значения. Например, для того, чтобы управлять точностью `Decimal`, необходимо изменить параметр контекста `prec`


```python
from decimal import Decimal, getcontext
getcontext().prec = 2
print(Decimal('4.34') / 4)
```

    1.1



```python
getcontext().prec = 3
print(Decimal('4.34') / 4)
```

    1.08


## Округление

Округление осуществляется с помощью метода `quantize()`. В качестве первого аргумента - объект `Decimal`, указывающий на формат округления:


```python
from decimal import Decimal, getcontext
getcontext().prec = 4 # установим точность округление
number = Decimal('2.1234123')
print(number.quantize(Decimal('1.000'))) # округление до 3 чисел в дробной части
```

    2.123



```python
print(number.quantize(Decimal('1.00'))) # округление до 2 чисел в дробной части
```

    2.12



```python
print(number.quantize(Decimal('1.0'))) # округление до 1 чисела в дробной части
```

    2.1


## Стратегия округления:

|               |                                                 |
|:--------------|:------------------------------------------------|
|`ROUND_CEILING`  |округление в направлении бесконечности (Infinity)|
|`ROUND_FLOOR`    |округляет в направлении минус бесконечности (- Infinity)|
|`ROUND_DOWN`     |округление в направлении нуля|
|`ROUND_HALF_EVEN`|округление до ближайшего четного числа. Число 4.9 округлится не до 5, а до 4 (потому что 5 - не четное)|
|`ROUND_HALF_DOWN`|округление до ближайшего нуля|
|`ROUND_UP`       |округление от нуля|
|`ROUND_05UP`     |округление от нуля (если последняя цифра после округления до нуля была бы 0 или 5, в противном случае к нулю)|


```python
from decimal import Decimal, ROUND_CEILING
number = Decimal("0.029")
print(number.quantize(Decimal("1.00"), ROUND_CEILING))
```

    0.03


Методы для работы с десятичными числами в `Decimal`:

|             |   |
|:------------|:--|
|`sqrt()`     |вычисляет квадратный корень из десятичного числа|
|`exp()`      |возвращает е/х (показатель степени) десятичного числа|
|`In()`       |используется для вычисления натурального логарифма десятичного числа|
|`log10()`    |используется для вычисления log (основание 10) десятичного числа|
|`as_tuple()` |возвращает десятичное чисодержащее 3аргумента, знак (0 для +, 1 для -), цифры и значение экспоненты|
|`fma(a, b)`  |"fma" означает сложить, умножить и добавить. Данный метод вычисляет (num * a) + b из чисел в аргументе. В этой функции округление пит * а не выполняется|
|`copy_sign()`|печатает первый аргумент, копируя знак из второго аргумента|

## Модуль Fraction

Этот модуль пригодится в тех случаях, когда необходимо выполнить вычисления с дробями, или когда результат должен быть выражен в формате дроби.


```python
from fractions import Fraction
print(Fraction(33.33))
```

    2345390243441541/70368744177664



```python
print(Fraction('33.33'))
```

    3333/100


Модуль `Fraction` особено полезен, потому что он автоматически уменьшает дробь. Выглядит это вон так:


```python
Fraction(153, 272)
```




    Fraction(9, 16)



Можно выполнить бинарные (двоичные) операции над дробью также просто, как вы используете `int`или `float`. Просто добавьте две фаркции:


```python
Fraction(1, 2) + Fraction(3, 4)
```




    Fraction(5, 4)



Теперь давайте попробуем возвести дробь в степень:


```python
Fraction(1, 8) ** Fraction(1, 2)
```




    0.3535533905932738



## Модуль math

Представляет более сложные математические функции


```python
import math
math.pi
```




    3.141592653589793




```python
math.sqrt(85)
```




    9.219544457292887



## Модуль random

Реализует генератор случайных чисел и функции случайного выбора.


```python
import random
random.random()
```




    0.5350142918445383



## Комплексные числа (complex)

В `Python` встроены также и комплексные числа:


```python
x = complex(1, 2)
print(x)
```

    (1+2j)



```python
y = complex(3,4)
print(y)
```

    (3+4j)



```python
z = x + y
print(z)
```

    (4+6j)



```python
z = x * y
print(z)
```

    (-5+10j)



```python
z = x / y
print(z)
```

    (0.44+0.08j)



```python
print(x.conjugate()) # сопряжённое число
```

    (1-2j)



```python
print(x.imag) # Мнимая часть
```

    2.0



```python
print(x.real) # Действительная часть
```

    1.0



```python
print(x > y) # комплексные числа нельзя сравнивать
```


    ---------------------------------------------------------------------------

    TypeError                                 Traceback (most recent call last)

    <ipython-input-111-0937005c35b0> in <module>
    ----> 1 print(x > y) # комплексные числа нельзя сравнивать
    

    TypeError: '>' not supported between instances of 'complex' and 'complex'


```
Traceback (most recent call last):
  File "", line 1, in
TypeError: unorderable types: complex() > complex()
```


```python
print(x == y) # но можно проверить на равенство
```

    False



```python
abs(3 + 4j) # модуль комплексного числа
```




    5.0




```python
pow(3 + 4j, 2)
```




    (-7+24j)



## Тип bool

Используется для обозначения логических величин. Имеет два значения true или false.


```python
for i in (False, True):
    for j in (False, True):
        print(i,j, ":", i and j, i or j, not i)
```

    False False : False False True
    False True : False True True
    True False : False True False
    True True : True True False


## Строки
 
Python строки бывают двух типов
- обычные сроки
- unicode строки
     
Фактически строка это последовательность символов в определённой кодировке.
 
Строки константы можно задать в программе с помощью строковых литералов.
 
Для литералов можно использовать на равне
- апострафы
- двойные кавычки
     
В строке могут присутствовать управляющие последовательности, например, перевод на новую строчку `\n`.
 
У строк существует ещё одна разновидность:
- необработанные литералы - это случай, когда следующие за обратной косой чертой символы не интерпретируются как спец. символы, а вставляются в строку как есть.


```python
s1 = "строка1"
s2 = "строка2\n"
my = "m|k = \1"
print(s1)
print(s2)
print(my)
```

    строка1
    строка2
    
    m|k = 


## Операции над строками
- конкатенация или объединение. Для выполнения данной операции применяется операция `+` 


```python
"abc" + "bcd"
```




    'abcbcd'




```python
s1 + s2
```




    'worldhello'



- повтор. Для выполнения операции повтора применяется символ `*`


```python
"A"*10
```




    'AAAAAAAAAA'



- Для выполнения операции форматирования применяется знак `%`


```python
"%s %i" % ("aBc", 12)
```




    'aBc 12'



В случае, если нам необходимо сложить строку и число. Число предварительно приводится к строке с использованием `str()`


```python
name = "Tom"
age = 23
info = "Name: " + name + "Age: " + str(age)
print(info)
```

    Name: TomAge: 23


- Сравнение строк. При сравнении строк применяется во внимание сами символы и их регистры. Цифровой символ условно меньше, чем любой алфавитный символ. Алфавитный символ верхнего регистра меньше, чем алфафитные символы нижнего регистра.


```python
s1 = "world"
s2 = "hello"
s3 = "hell1"
print(s1 > s2)
print(s2 == s3)
```

    True
    False


## Тип картедж

Для представления константной последовательности разнородных объектов используется тип картедж. Литерал картеджа обычно записывается в круглых скобках.


```python
p = (1.2, 3.4, 0.9)
for s in "one", "two", "three": # организация цикла по значению картеджа
    print(s)
```

    one
    two
    three



```python
one_item = (1,)
print(one_item)
```

    (1,)



```python
empty=()
print(empty)
```

    ()



```python
p1 = 1,3,9
print(p1)
```

    (1, 3, 9)



```python
p2 = 3,8,5,
print(p2)
```

    (3, 8, 5)


## Тип list - список

> Списки в Python - упорядоченные изменяемые коллекции объектов произвольных типов (почти как массив, но типы могут отличаться).

> Чтобы использовать списки, их нужно создать. Создать список можно несколькими способами. Например, можно обработать любой итерируемый объект (например, строку) встроенной функцией list: ...

Списки можно задавать с помощью литералов записанных в квадратных скобках или посредством списка включения


```python
lst1 = [1,2,3]
print(lst1)
```

    [1, 2, 3]



```python
lst2 = [x**2 for x in range(10) if x%2 == 1]
print(lst2)
```

    [1, 9, 25, 49, 81]



```python
lst3 = list("abcde")
print(lst3)
```

    ['a', 'b', 'c', 'd', 'e']


Для работы со списком применяются специальные методы, последовательности

При работе с последовательностями нужно учитывать, что они бывают не изменчивыми и изменчивыми
 
```python
len(S)
x in S # проверяется принадлежность элемента последовательности S
S + S1
S * n # последовательность из n раз повторений S
S[i] # возвращается iтый элемент последовательности S
S[i:j:d] # сред из последовательности s от i до j с шагом d
min(S)
max(S) # максимальное значение
del S[i:j:d] # удаление элемента
```

Далее расмотрим методы применяемые к изменчивым последовательностям, например, к списку
 
```python
.append()
.count() # считает количество элементов 
.extend() # добавляет концу последовательности последовательность s
.index() # возвращает наименьшее i, что s[i] = i, если не найден повзвращается исключение
.insert() # добавляет элемент x в iтый промежуток
.pop() # Возвращает iтый элемент удаляя из последовательности
.reverse() # меняет порядок элементов на обратный
.sort([cmp func]) # сортировка
 ```
